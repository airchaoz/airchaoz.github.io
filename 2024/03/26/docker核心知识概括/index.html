<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>docker核心知识概括 - echo&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="echo"><meta name="msapplication-TileImage" content="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202408101608074.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="echo"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Docker架构 Docker的核心组件包括：  Docker客户端：Client Docker服务端：Docker Daemon Docker镜像：Image Registry：镜像远端 Docker容器：Container"><meta property="og:type" content="blog"><meta property="og:title" content="docker核心知识概括"><meta property="og:url" content="http://www.airchaoz.top/2024/03/26/docker%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E6%A6%82%E6%8B%AC/"><meta property="og:site_name" content="echo&#039;s blog"><meta property="og:description" content="Docker架构 Docker的核心组件包括：  Docker客户端：Client Docker服务端：Docker Daemon Docker镜像：Image Registry：镜像远端 Docker容器：Container"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262322463.jpg"><meta property="og:image" content="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262311417.png"><meta property="og:image" content="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262312425.png"><meta property="og:image" content="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262312289.png"><meta property="og:image" content="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262313554.png"><meta property="og:image" content="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262313906.png"><meta property="og:image" content="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262314333.png"><meta property="og:image" content="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262315841.png"><meta property="og:image" content="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262315715.png"><meta property="article:published_time" content="2024-03-26T15:04:32.000Z"><meta property="article:modified_time" content="2024-08-10T14:08:07.000Z"><meta property="article:author" content="echo"><meta property="article:tag" content="Docker"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262322463.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.airchaoz.top/2024/03/26/docker%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E6%A6%82%E6%8B%AC/"},"headline":"docker核心知识概括","image":["https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262322463.jpg","https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262311417.png","https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262312425.png","https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262312289.png","https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262313554.png","https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262313906.png","https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262314333.png","https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262315841.png","https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262315715.png"],"datePublished":"2024-03-26T15:04:32.000Z","dateModified":"2024-08-10T14:08:07.000Z","author":{"@type":"Person","name":"echo"},"publisher":{"@type":"Organization","name":"echo's blog","logo":{"@type":"ImageObject","url":{"text":"echo's blog"}}},"description":"Docker架构 Docker的核心组件包括：  Docker客户端：Client Docker服务端：Docker Daemon Docker镜像：Image Registry：镜像远端 Docker容器：Container"}</script><link rel="canonical" href="http://www.airchaoz.top/2024/03/26/docker%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E6%A6%82%E6%8B%AC/"><link rel="icon" href="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202408101608074.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-9N9JB3XQG1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-9N9JB3XQG1');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="echo's blog" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">echo&#039;s blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/changelog">ChangeLog</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/airchaoz"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-03-26T15:04:32.000Z" title="3/26/2024, 11:04:32 PM">2024-03-26</time>发表</span><span class="level-item"><time dateTime="2024-08-10T14:08:07.000Z" title="8/10/2024, 10:08:07 PM">2024-08-10</time>更新</span><span class="level-item">41 分钟读完 (大约6164个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">docker核心知识概括</h1><div class="content"><h1 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h1><p><img src="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262322463.jpg"></p>
<p>Docker的核心组件包括：</p>
<ul>
<li>Docker客户端：Client</li>
<li>Docker服务端：Docker Daemon</li>
<li>Docker镜像：Image</li>
<li>Registry：镜像远端</li>
<li>Docker容器：Container<span id="more"></span>
Docker 采用的是 Client&#x2F;Server 架构。客户端向服务器发送请求，服务器负责构建、运行和分发容器。客户端和服务器可以运行在同一个 Host 上，客户端也可以通过 socket 或 REST API 与远程的服务器通信。</li>
</ul>
<h2 id="Docker客户端"><a href="#Docker客户端" class="headerlink" title="Docker客户端"></a>Docker客户端</h2><p>最常用的 Docker 客户端是 docker 命令，在安装docker时一并装好。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>docker run</td>
<td>运行一个容器</td>
</tr>
<tr>
<td>docker ps</td>
<td>列出运行中的容器</td>
</tr>
<tr>
<td>docker ps -a</td>
<td>列出所有容器，包括停止的容器</td>
</tr>
<tr>
<td>docker images</td>
<td>列出本地镜像</td>
</tr>
<tr>
<td>docker pull</td>
<td>从远端仓库拉取镜像</td>
</tr>
<tr>
<td>docker build</td>
<td>基于Dockerfile构建镜像</td>
</tr>
<tr>
<td>docker exec</td>
<td>在运行中的容器中执行命令</td>
</tr>
<tr>
<td>docker stop</td>
<td>停止一个或多个运行中的容器</td>
</tr>
<tr>
<td>docker rm</td>
<td>删除一个或多个容器</td>
</tr>
<tr>
<td>docker rmi</td>
<td>删除一个或多个本地镜像</td>
</tr>
<tr>
<td>docker network ls</td>
<td>列出所有网络</td>
</tr>
<tr>
<td>docker volume ls</td>
<td>列出所有卷</td>
</tr>
<tr>
<td>docker inspect</td>
<td>提供关于指定Docker对象的详细信息</td>
</tr>
<tr>
<td>docker logs</td>
<td>查看容器的日志</td>
</tr>
<tr>
<td>docker cp</td>
<td>从容器复制文件到主机</td>
</tr>
<tr>
<td>docker commit</td>
<td>创建一个新的镜像</td>
</tr>
</tbody></table>
<p>除了docker命令工具之外，也可以通过REST API与Docker服务端通信，一些GUI客户端就是基于此实现的。例如Portainer，它提供了直观的用户界面，使用户能够轻松地管理容器、镜像、卷、网络等Docker组件，而无需使用命令行界面。</p>
<p><img src="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262311417.png"></p>
<h2 id="Docker-服务端"><a href="#Docker-服务端" class="headerlink" title="Docker 服务端"></a>Docker 服务端</h2><p>Docker Daemon是服务端，负责创建、运行、监控容器，构建、存储镜像。在Linux系统中有这么几个常用的路径和文件：</p>
<p><code>/var/run/docker.sock</code> ：Docker守护进程默认监听一个Unix域套接字（Unix domain socket）来接受本地通信，这个套接字通常被称为Docker套接字。</p>
<p><code>/etc/docker/daemon.json</code> ：这个文件包含Docker守护进程的配置选项，例如日志设置、存储驱动、网络配置等。如果该文件不存在，Docker将使用默认配置。</p>
<p><code>/var/lib/docker</code> ：这是Docker用于存储镜像、容器、卷等数据的默认目录。</p>
<p>Docker daemon 默认只能响应来自本地 Host 的客户端请求，如果需要响应网络请求需要修改docker服务配置。</p>
<h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><p>Docker镜像是一个轻量级、独立、可执行的软件包，可以包括代码、运行时、库、环境变量和配置文件。docker镜像是docker的基础，docker通过镜像生成容器，容器也可以打包成镜像，其具有以下特性：</p>
<ul>
<li>不可变性：镜像的内容是不可变的，任何对镜像的修改都会生成一个新的镜像。这种不可变性确保了在不同环境中一致性的部署和运行。</li>
<li>轻量性：镜像采用分层存储的设计理念，由多个只读层组成，每个层都包含特定的文件或配置，每个只读层可以给多个镜像共享，从而节省存储空间和提高效率。</li>
</ul>
<p><code>docker pull</code>命令可以从Registry下载镜像。</p>
<p><code>docker run</code>命令则是先下载镜像（如果本地没有），然后再启动容器。</p>
<h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><p>Registry是存放Docker镜像的仓库，Registry分私有和公有两种。</p>
<p>DockerHub（<a target="_blank" rel="noopener" href="https://hub.docker.com/%EF%BC%89%E6%98%AF%E9%BB%98%E8%AE%A4%E7%9A%84Registry%EF%BC%8C%E7%94%B1Docker">https://hub.docker.com/）是默认的Registry，由Docker</a> 公司维护，上面有数以万计的镜像，用户可以自由下载和使用。</p>
<p>出于对速度或安全的考虑，用户也可以创建自己的私有Registry。</p>
<h1 id="Docker镜像-1"><a href="#Docker镜像-1" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><h2 id="镜像的分层结构"><a href="#镜像的分层结构" class="headerlink" title="镜像的分层结构"></a>镜像的分层结构</h2><p>docker采用分层结构，通常来说最底层镜像能提供一个基本的操作系统环境，用户可以根据需要安装和配置软件，这样的镜像称作base 镜像。base 镜像从0开始构建，其他镜像以此为基础进行拓展。一般来说base 镜像是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu、Debian、CentOS 等。</p>
<p><strong>平时我们在虚拟机上安装Linux操作系统都是好几个G，为什么docker才200M左右呢？</strong></p>
<p>docker使用的base镜像是经过精简的，只包括最基本的命令、工具和程序库。相比物理机安装的操作系统会小很多。另外base镜像只包括操作系统的rootfs部分，不包括bootfs和kermel，并且和Host共用kernel。</p>
<p>docker的每一层都代表着代码、运行时、库、环境变量和配置文件。下图为例，该新镜像在 Debian base 镜像上构建，添加了一层emacs 编辑器，再添加了一层apache2。新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p>
<p><img src="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262312425.png"></p>
<p>当容器启动时，还会添加一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层“。<strong>所有对容器的改动，无论添加、删除，还是修改文件都只会发生在容器层中。</strong>只有容器层是可写的，容器层下面的所有镜像层都是只读的。 只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。</p>
<p><strong>分层结构的好处</strong><br>最主要的目的是共享资源，如果有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了，而且镜像的每一层都可以被共享 。</p>
<p>使用docker history命令可以检查镜像的分层结构，例如：</p>
<p><img src="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262312289.png"></p>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>Docker 提供了两种构建镜像的方法： <code>docker commit</code> 命令与 Dockerfile 构建文件</p>
<h3 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h3><p><code>docker commit</code> 命令是创建新镜像最直观的方法，每次使用一次该命令，则镜像多添加一层，其过程包含三个步骤：</p>
<ul>
<li>运行容器</li>
<li>进入容器内部进行修改</li>
<li>使用docker commit命令将修改完的容器保存为新的镜像</li>
</ul>
<p>Docker 并不建议用户通过这种方式构建镜像。原因如下 ：</p>
<ol>
<li>手动创建镜像效率低下且可重复性弱；</li>
<li>镜像创建过程不透明，无法对镜像进行审计。</li>
</ol>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile 是一个文本文件，记录了镜像构建的所有步骤。<br>下面列出了 Dockerfile 中最常用的指令，完整列表和说明可参看官方文档</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定BASE镜像</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>设置镜像的作者，可以是任意字符串</td>
</tr>
<tr>
<td>COPY</td>
<td>将文件从buildcontext复制到镜像，COPY支持两种形式：COPY src dest 与COPY[“src”,”dest”]，注意：src只能指定buildcontext 中的文件或目录。</td>
</tr>
<tr>
<td>ADD</td>
<td>与COPY类似，从build context 复制文件到镜像。不同的是，如果src是归档文件（tar、zip、tgz、xz 等），文件会被自动解压到dest。</td>
</tr>
<tr>
<td>ENV</td>
<td>设置环境变量，环境变量可被后面的指令使用。例如：ENV MY_VERSION 1.3 RUN apt-get install -y mypackage&#x3D;$MY_VERSION</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>指定容器中的进程会监听某个端口，Docker可以将该端口暴露出来</td>
</tr>
<tr>
<td>VOLUME</td>
<td>将文件或目录声明为volume</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>为后面的RUN、CMD、ENTRYPOINT、ADD或COPY指令设置镜像中的当前工作目录</td>
</tr>
<tr>
<td>RUN</td>
<td>在容器中运行指定的命令</td>
</tr>
<tr>
<td>CMD</td>
<td>容器启动时运行指定的命令</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>设置容器启动时运行的命令。</td>
</tr>
</tbody></table>
<p>Dockerfile 的注释以”#” 开头<br>RUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆，但是有些细微区别：</p>
<ul>
<li>RUN：执行命令并创建新的镜像层，RUN经常用于安装软件包。</li>
<li>CMD：设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。</li>
<li>ENTRYPOINT：配置容器启动时运行的命令。</li>
</ul>
<p>CMD单独使用时可以使用<code>[命令] [参数]</code> 的形式，当和ENTRYPOINT结合使用时可以作为参数输入，使参数的设定更加灵活。</p>
<p>例如：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;Hello&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;world&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，如果直接运行容器而不带任何命令行参数，它会输出<code>Hello world</code>。这是因为<code>ENTRYPOINT</code>指定了<code>echo</code>命令，而<code>CMD</code>提供了默认参数<code>world</code>。</p>
<p>如果在运行容器时指定了额外的参数，比如<code>docker run &lt;image&gt; Docker!</code>，那么<code>CMD</code>中的<code>world</code>会被忽略，输出将会是<code>Hello Docker!</code>。</p>
<p><strong>Dockerfile支持Shell和Exec格式的命令</strong></p>
<p>Shell格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;instruction&gt; &lt;command&gt;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install python3</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello world&quot;</span></span></span><br><span class="line">NTRYPOINT echo <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>当指令执行时，shell 格式底层会调用<code>/bin/sh-c [command]</code><br>Exec格式：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;instruction&gt; [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;paraml&quot;</span>, <span class="string">&quot;param2&quot;</span>, ...]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;apt-get&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;python3&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/echo&quot;</span>, <span class="string">&quot;Hello world&quot;</span> ]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/bin/echo&quot;</span>，<span class="string">&quot;Helloworld&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>apt-get update 和 apt-get install 被放在一个 RUN 指令中执行，这样能够保证每次安装的是最新的包。如果 apt-get install 在单独的 RUN 中执行，则会使用 apt-get update 创建镜像层，而这一层可能是很久以前缓存的。</p>
<h1 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h1><h2 id="容器的启动"><a href="#容器的启动" class="headerlink" title="容器的启动"></a>容器的启动</h2><p>docker run是运行容器的命令，当启动时容器会执行指定的CMD或ENTRYPOINT指令，也可以手动指令运行的命令，但是当命令执行结束时容器就会退出。</p>
<p>例如运行<code>docker run hello-world</code></p>
<p><img src="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262313554.png"></p>
<p>容器的生命周期依赖于启动时执行的命令，只要该命令不结束，容器也就不会退出。 例如我们运行下面这一段不断循环的脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu /bin/bash -c <span class="string">&quot;while true ; do sleep 1; done&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以打开另一个终端查看容器的状态，发现容器始终在运行。为了避免程序在前台运行，可以添加参数<code>-d</code>让程序在后台运行，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d ubuntu /bin/bash -c <span class="string">&quot;while true ; do sleep 1; done&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="进入容器内部"><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h2><p>按用途容器大致可分为两类：服务类容器和工具类的容器，大多数都是服务类的容器，需要常驻在后台对外提供服务。对于这种常驻在后台运行的容器，有时我们也需要进到容器里去做一些工作，比如查看日志、调试、启动其他进程等。</p>
<h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach"></a>docker attach</h3><p>通过 docker attach命令可以 attach 到容器启动命令的终端</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach [容器ID]</span><br></pre></td></tr></table></figure>

<p>通过 Ctrl+p, 然后 Ctrl+q 组合键退出 attach 终端。</p>
<h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h3><p>另一种方式是通过 docker exec 进入相同的容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it [容器ID] bash</span><br></pre></td></tr></table></figure>

<p>上述命令的含义是在容器内新开一个终端，并执行bash命令打开bash终端。需要注意的是，有些容器内没有bash，可以选择sh命令。</p>
<p>这两个方式有些不同，attach是接入到原来的终端当中，可以直接查看容器输出的内容。而exec是新开一个终端，可以执行Linux命令。建议如果想直接在终端中查看启动命令的输出，用 attach；其他情况一律使用 exec。</p>
<h2 id="容器的启停"><a href="#容器的启停" class="headerlink" title="容器的启停"></a>容器的启停</h2><p>docker命令指定容器有两种方式，第一种是使用容器ID，ID可以使用短ID，即前几位就行，第二种是指定容器名</p>
<p>例如:</p>
<p><img src="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262313906.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start aa9198422ccb <span class="comment"># 使用完整的ID</span></span><br><span class="line">docker start aa <span class="comment"># 使用前几位ID，只需要能够和其他容器进行区分就足够</span></span><br><span class="line">docker start practical_chandrasekhar <span class="comment"># 使用容器名指定</span></span><br></pre></td></tr></table></figure>

<p><strong>docker stop</strong></p>
<p>通过 docker stop 可以停止运行的容器，docker stop 命令本质上是向该进程发送一个SIGTERM 信号。如果想快速停止容器，可使用 docker kill 命令，其作用是向容器进程发送SIGKILL 信号</p>
<p><strong>docker start</strong></p>
<p>对于处于停止状态的容器，可以通过docker start重新启动，docker start会保留容器的第一次启动时的所有参数。</p>
<p><strong>docker restart</strong></p>
<p>docker restart 可以重启容器，其作用就是依次执行 docker stop 和 docker start。</p>
<p>容器可能会因某种错误而停止运行。对于服务类容器，我们通常希望在这种情况下容器能够自动重启。启动容器时设置–restart就可以达到这个效果，–restart&#x3D;always 意味着无论容器因何种原因退出（包括正常退出），都立即重启；该参数的形式还可以是 –restart&#x3D;on-fhilure:3, 意思是如果启动进程退出代码非 0, 则重启容器，最多重启 3 次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -—restart=always httpd</span><br></pre></td></tr></table></figure>

<h2 id="容器的暂停与恢复"><a href="#容器的暂停与恢复" class="headerlink" title="容器的暂停与恢复"></a>容器的暂停与恢复</h2><p>docker pause 命令可以让容器暂停，docker unpause 可以使其恢复运行。</p>
<h2 id="容器的删除"><a href="#容器的删除" class="headerlink" title="容器的删除"></a>容器的删除</h2><p>docker rm 是删除容器，docker rmi 是删除镜像，删除之前需要先docker stop停止容器。</p>
<h2 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h2><h3 id="内存限额"><a href="#内存限额" class="headerlink" title="内存限额"></a>内存限额</h3><p>一个docker host上会运行若干容器，每个容器都需要CPU、内存和IO资源。对于KVM、VMware等虚拟化技术，用户可以控制分配多少CPU、内存资源给每个虚拟机。对于容器，Docker也提供了类似的机制避免某个容器因占用太多资源而影响其他容器乃至整个host的性能。</p>
<p>与操作系统类似，容器可使用的内存包括两部分：物理内存和 swap。 Docker 通过下面两组参数来控制容器内存的使用量。</p>
<ol>
<li>-m 或 -memory：设置内存的使用限额，例如 100MB, 2GB</li>
<li>-memory-swap：设置内存+swap 的使用限额。</li>
</ol>
<p>如果在启动容器时只指定 -m 而不指定 -memory-swap, 那么 -memory-swap 默认为 -m的两倍</p>
<p>例如以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -m 200M —memory-swap=300M ubuntu</span><br></pre></td></tr></table></figure>

<p>分配的内存超过限额，容器会退出。</p>
<h3 id="CPU限额"><a href="#CPU限额" class="headerlink" title="CPU限额"></a>CPU限额</h3><p>默认设置下，所有容器可以平等地使用hostCPU资源并且没有限制。Docker可以通过-c或–cpu-shares设置容器使用CPU的权重。如果不指定，默认值为1024。与内存限额不同，通过-设置的cpu share并不是CPU资源的绝对数量，而是一个相对的权重值。某个容器最终能分配到的CPU资源取决于它的cpushare占所有容器cpushare总和的比例。换句话说：通过cpu share可以设置容器使用CPU的优先级。</p>
<p>例如以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run —name <span class="string">&quot;container_A&quot;</span> -c 1024 ubuntu</span><br></pre></td></tr></table></figure>

<h3 id="Block-IO-带宽限额"><a href="#Block-IO-带宽限额" class="headerlink" title="Block IO 带宽限额"></a>Block IO 带宽限额</h3><p>Block IO 是另一种可以限制容器使用的资源。Block 10 指的是磁盘的读写，docker 可通过设置权重、限制 bps 和 iops 的方式控制容器读写磁盘的带宽，下面分别讨论。</p>
<p><strong>1.block IO权重</strong></p>
<p>默认情况下，所有容器能平等地读写磁盘，可以通过设置 -blkio-weight 参数来改变容器block 10 的优先级。</p>
<p><code>--blkio-weight</code> 与 <code>--cpu-shares</code>类似，设置的是相对权重值，默认为 500。在下面的例子中，containerA 读写磁盘的带宽是 containerB 的两倍。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ―name container_A ―blkio-weight 600 ubuntu</span><br><span class="line">docker run -it —name container_B ―blkio-weight 300 ubuntu</span><br></pre></td></tr></table></figure>

<p><strong>2. 限制 bps 和 iops</strong><br>bps 是 byte per second, 每秒读写的数据量<br>iops 是 io per second, 每秒 IO 的次数。<br>可通过以下参数控制容器的 bps 和 iops：</p>
<p><code>--device-read-bps</code>:限制读某个设备的 bps。</p>
<p><code>--device-write-bps</code>:限制写某个设备的 bps。</p>
<p><code>--device-read-iops</code>: 限制读某个设备的 iops。</p>
<p><code>--device-write-iops</code>: 限制写某个设备的 iops。</p>
<p>下面这个例子限制容器写 &#x2F;dev&#x2F;sda 的速率为 30 MB&#x2F;s：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -一device-write-bps /dev/sda: 30MB ubuntu</span><br></pre></td></tr></table></figure>

<h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="None网络"><a href="#None网络" class="headerlink" title="None网络"></a>None网络</h2><p>none 网络就是什么都没有的网络。挂在这个网络下的容器除了 lo, 没有其他任何网卡。容器创建时，可以通过 -network&#x3D;none 指定使用 none 网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network=none busybox</span><br></pre></td></tr></table></figure>

<h2 id="Host网络"><a href="#Host网络" class="headerlink" title="Host网络"></a>Host网络</h2><p>连接到 host 网络的容器共享 Docker host 的网络栈，容器的网络配置与 host 完全一样。</p>
<p>可以通过—network&#x3D;host 指定使用 host 网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --network=host busybox</span><br></pre></td></tr></table></figure>

<p>直接使用 Docker host 的网络最大的好处就是性能，如果容器对网络传输效率有较高要求，则可以选择 host 网络。当然不便之处就是牺牲一些灵活性，比如要考虑端口冲突问题， Docker host 上已经使用的端口就不能再用了。</p>
<p>Docker host 的另一个用途是让容器可以直接配置 host 网路，比如某些跨 host 的网络解决</p>
<p>方案，其本身也是以容器方式运行的，这些方案需要对网络进行配置，比如管理 iptables。</p>
<h2 id="Bridge网络"><a href="#Bridge网络" class="headerlink" title="Bridge网络"></a>Bridge网络</h2><p>Docker 安装时会创建一个命名为 docker0 的 Linux bridge。如果不指定-network, 创建的容器默认都会挂到 docker0 上。</p>
<p>默认的docker网关是172.17.0.1，容器创建时，docker 会自动从 172.17.0.0&#x2F;16 中分配一个 IP, 这里 16 位的掩码保证有足够多的 IP 可以供容器使用。</p>
<p><img src="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262314333.png"></p>
<h2 id="User-defined网络"><a href="#User-defined网络" class="headerlink" title="User-defined网络"></a>User-defined网络</h2><p>除了 none、host、 bridge 这三个自动创建的网络，用户也可以根据业务需要创建 user-defined 网络。<br>Docker 提供三种 user-defined 网络驱动：bridge、overlay 和 macvlano overlay 和 macvlan用于创建跨主机的网络</p>
<p>bridge网络：</p>
<p>类似上述docker0这个bridge，可以通过bridge 驱动创建新的网络</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --driver bridge my_net</span><br></pre></td></tr></table></figure>

<p>通过<code>brctl show</code>命令和<code>docker network inspect my_net</code>命令可以查看新建网络的信息</p>
<p><img src="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262315841.png"></p>
<p><img src="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202403262315715.png"><br>也可以在创建bridge时使用<code>--subnet</code>和<code>--gateway</code>参数来指定网段，相应的也可以在容器运行时指定容器的静态IP。</p>
<p><code>docker network connect</code>命令可以将两个bridge连通</p>
<h2 id="Docker-DNS-Server"><a href="#Docker-DNS-Server" class="headerlink" title="Docker DNS Server"></a>Docker DNS Server</h2><p>通过IP访问容器虽然满足了通信的需求，但还是不够灵活。因为在部署应用之前可能无法确定IP，部署之后再指定要访问的IP会比较麻烦。对于这个问题，可以通过docker自带的DNS服务解决。</p>
<p>从Docker1.10版本开始，dockerdaemon实现了一个内嵌的DNS server，使容器可以直接通过“容器名”通信。方法很简单，只要在启动时用–name为容器命名就可以了。下面启动两个容器bbox1和bbox2：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it —network=my_net2 --name=bboxl busybox</span><br><span class="line">docker run -it—network=my_net2 --name=bbox2 busybox</span><br></pre></td></tr></table></figure>

<p>使用 docker DNS 有个限制：只能在 user-defined 网络中使用。也就是说，默认的 bridge网络是无法使用 DNS 的。</p>
<h1 id="Docker存储"><a href="#Docker存储" class="headerlink" title="Docker存储"></a>Docker存储</h1><p>Docker 为容器提供了两种存放数据的资源</p>
<ol>
<li>由 storage driver 管理的镜像层和容器层</li>
<li>Data Volume</li>
</ol>
<h2 id="storage-driver"><a href="#storage-driver" class="headerlink" title="storage driver"></a>storage driver</h2><p>前面讲到容器的分层结构特性：Copy-on-Write:</p>
<ol>
<li>新数据会直接存放在最上面的容器层。</li>
<li>修改现有数据会先从镜像层将数据复制到容器层，修改后的数据直接保存在容器层中，镜像层保持不变。</li>
<li>如果多个层中有命名相同的文件，用户只能看到最上面那层中的文件。</li>
</ol>
<p>分层结构使镜像和容器的创建、共享以及分发变得非常高效，而这些都要归功于 Docker storage driver。正是 storage driver 实现了多层数据的堆叠并为用户提供一个单一的合并之后的统一视图。</p>
<p>Docker 支持多种 storage driver, 有 AUFS、Device Mapper、Btrfc、OveHayFS、VFS 和ZFS。它们都能实现分层的架构，同时又有各自的特性。对于 Docker 用户来说，具体选择使用哪个 storage driver 是一个难题，因为：</p>
<ol>
<li>没有哪个 driver 能够适应所有的场景。</li>
<li>driver 本身在快速发展和迭代。</li>
</ol>
<p>所以优先使用 Linux 发行版默认的 storage driver。</p>
<p>对于某些容器，直接将数据放在由 storage driver 维护的层中是很好的选择，比如那些无状态的应用。无状态意味着容器没有需要持久化的数据，随时可以从镜像直接创建。</p>
<p>但对于另一类应用这种方式就不合适了，它们有持久化数据的需求，容器启动时需要加载已有的数据，容器销毁时希望保留产生的新数据，也就是说，这类容器是有状态的。</p>
<p>这就要用到 Docker 的另一种存储机制：Data Volume。</p>
<h2 id="Data-Volume"><a href="#Data-Volume" class="headerlink" title="Data Volume"></a>Data Volume</h2><p>Data Volume 本质上是 Docker Host 文件系统中的目录或文件，能够直接被 mount 到容器的文件系统中，具有以下优点：</p>
<ol>
<li>Data Volume 是目录或文件，而非没有格式化的磁盘 (块设备)</li>
<li>容器可以读写 volume 中的数据。</li>
<li>volume 数据可以被永久地保存，即使使用它的容器已经销毁。</li>
</ol>
<p>volume实际上是 docker host 文件系统的一部分，所以 volume 的容量取决于文件系统当前未使用的空间，目前还没有方法设置 volume 的容量。</p>
<p>在具体的使用上，docker 提供了两种类型的 volume：<code>bind mount</code> 和 <code>docker managed</code></p>
<p>volume</p>
<h3 id="bind-mount"><a href="#bind-mount" class="headerlink" title="bind mount"></a>bind mount</h3><p>bind mount用于将主机文件系统中的目录或文件挂载到Docker容器中。这种挂载方式允许容器与主机之间共享文件和目录，使得容器中的应用程序可以访问主机上的文件系统。</p>
<p>在运行Docker容器时，可以通过<code>-v</code>或<code>--volume</code>选项来指定bind mount。语法通常是<code>-v &lt;host_path&gt;:&lt;container_path&gt;</code>，其中<code>&lt;host_path&gt;</code>是主机上的路径，<code>&lt;container_path&gt;</code>**是容器内的路径。Docker会将主机路径和容器路径之间建立一个映射关系，容器内对该路径的访问实际上是对主机文件系统中相应路径的访问。</p>
<p>bind mount 的使用直观高效，易于理解，但它也有不足的地方：bind mount 需要指定 host文件系统的特定路径，这就限制了容器的可移植性，当需要将容器迁移到其他 host, 而该 host没有要 mount 的数据或者数据不在相同的路径时，操作会失败</p>
<h3 id="Docker-managed-volumes"><a href="#Docker-managed-volumes" class="headerlink" title="Docker managed volumes"></a>Docker managed volumes</h3><p>Docker managed volumes（Docker管理的卷）是一种Docker容器中用于存储数据的技术，与bind mount类似，但由Docker自动管理。相比于bind mount，Docker managed volumes提供了更多的便利和一些额外的功能，例如跨平台兼容性、易于备份和恢复、更好的性能等。</p>
<p>可以通过 docker inspect 查看 volume, 也可以用 docker volume 命令查看有哪些docker volume</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>docker核心知识概括</p><p><a href="http://www.airchaoz.top/2024/03/26/docker核心知识概括/">http://www.airchaoz.top/2024/03/26/docker核心知识概括/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>echo</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-03-26</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2024-08-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Docker/">Docker</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/04/23/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84MMAP/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">内存映射MMAP</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/02/14/GDB-Dashboard%E7%9A%84%E4%BD%BF%E7%94%A8/"><span class="level-item">GDB-Dashboard的使用</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card" id="comments"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://www.airchaoz.top/2024/03/26/docker%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E6%A6%82%E6%8B%AC/';
            this.page.identifier = '2024/03/26/docker核心知识概括/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'echos-blog-2' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://blog-512.oss-cn-shenzhen.aliyuncs.com/202401032048869.png" alt="echo"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">echo</p><p class="is-size-6 is-block">C++ Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>GuangDong, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">24</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">16</p></a></div></div></nav></div></div><!--!--><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CMake/"><span class="tag">CMake</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Docker/"><span class="tag">Docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Qt/"><span class="tag">Qt</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><span class="tag">内存模型</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tag">并发编程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/"><span class="tag">并行计算</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><span class="tag">性能优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98/"><span class="tag">操作系统, 内存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/"><span class="tag">效率工具</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><span class="tag">源码阅读</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C-%E6%8A%93%E5%8C%85/"><span class="tag">网络, 抓包</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91/"><span class="tag">跨平台开发</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Docker架构"><span class="level-left"><span class="level-item">1</span><span class="level-item">Docker架构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Docker客户端"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Docker客户端</span></span></a></li><li><a class="level is-mobile" href="#Docker-服务端"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Docker 服务端</span></span></a></li><li><a class="level is-mobile" href="#Docker镜像"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Docker镜像</span></span></a></li><li><a class="level is-mobile" href="#Registry"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">Registry</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Docker镜像-1"><span class="level-left"><span class="level-item">2</span><span class="level-item">Docker镜像</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#镜像的分层结构"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">镜像的分层结构</span></span></a></li><li><a class="level is-mobile" href="#构建镜像"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">构建镜像</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#docker-commit"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">docker commit</span></span></a></li><li><a class="level is-mobile" href="#Dockerfile"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">Dockerfile</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Docker容器"><span class="level-left"><span class="level-item">3</span><span class="level-item">Docker容器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#容器的启动"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">容器的启动</span></span></a></li><li><a class="level is-mobile" href="#进入容器内部"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">进入容器内部</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#docker-attach"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">docker attach</span></span></a></li><li><a class="level is-mobile" href="#docker-exec"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">docker exec</span></span></a></li></ul></li><li><a class="level is-mobile" href="#容器的启停"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">容器的启停</span></span></a></li><li><a class="level is-mobile" href="#容器的暂停与恢复"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">容器的暂停与恢复</span></span></a></li><li><a class="level is-mobile" href="#容器的删除"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">容器的删除</span></span></a></li><li><a class="level is-mobile" href="#资源限制"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">资源限制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#内存限额"><span class="level-left"><span class="level-item">3.6.1</span><span class="level-item">内存限额</span></span></a></li><li><a class="level is-mobile" href="#CPU限额"><span class="level-left"><span class="level-item">3.6.2</span><span class="level-item">CPU限额</span></span></a></li><li><a class="level is-mobile" href="#Block-IO-带宽限额"><span class="level-left"><span class="level-item">3.6.3</span><span class="level-item">Block IO 带宽限额</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Docker网络"><span class="level-left"><span class="level-item">4</span><span class="level-item">Docker网络</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#None网络"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">None网络</span></span></a></li><li><a class="level is-mobile" href="#Host网络"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">Host网络</span></span></a></li><li><a class="level is-mobile" href="#Bridge网络"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">Bridge网络</span></span></a></li><li><a class="level is-mobile" href="#User-defined网络"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">User-defined网络</span></span></a></li><li><a class="level is-mobile" href="#Docker-DNS-Server"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">Docker DNS Server</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Docker存储"><span class="level-left"><span class="level-item">5</span><span class="level-item">Docker存储</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#storage-driver"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">storage driver</span></span></a></li><li><a class="level is-mobile" href="#Data-Volume"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">Data Volume</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#bind-mount"><span class="level-left"><span class="level-item">5.2.1</span><span class="level-item">bind mount</span></span></a></li><li><a class="level is-mobile" href="#Docker-managed-volumes"><span class="level-left"><span class="level-item">5.2.2</span><span class="level-item">Docker managed volumes</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">echo&#039;s blog</a><p class="is-size-7"><span>&copy; 2025 echo</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>